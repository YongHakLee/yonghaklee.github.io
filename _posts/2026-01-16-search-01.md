---
title: LangChain & LangGraph Overview
date: 2026-01-16 12:23:17 +0900
categories: [Works, Search]
tags: [works, search]     # TAG names should always be lowercase
math: true
---

> [Slides](/assets/data/pdfs/LangChainLangGraphInfographic.pdf)
{: .prompt-info}

## LangChain (Building Blocks)
---

LangChain은 LLM을 데이터 소스나 계산 리소스에 쉽게 연결하기 위한 오케스트레이션 프레임워크이다. 결합성 (Composability)을 중심으로 설계되었다.

**Chains (DAGs)**
- Directed Acyclic Graphs. 연결에 방향이 있고, 일방 통행이면서 출발했던 지점으로 다시 돌아오는 경로가 없는 흐름 자료 구조.
- 직선적이고 분기되는 단계의 연속을 만든다. (예: 프롬프트 -> LLM -> 출력)
- 외부 통합 (OpenAI, HuggingFace, Vector DB 등)을 추상화하여 쉽게 사용하게 한다.
  
**주요 구성 요소**
- Prompts: 입력 템플릿
- Retrievers: 데이터를 가져오는 인터페이스 (RAG)
- Memory: 대화 기록 저장 (단순 리스트 형태인 경우가 많음)
- Tools: LLM이 호출할 수 있는 기능 (구글 검색, 계산기 등)
  
**한계점**
- 기존의 LangChain Agent는 커스터마이징과 디버깅이 어려웠다. 특히 LLM이 생각을 바꾸거나 특정 조건이 충족될 때까지 무한히 재시도하는 복잡한 반복 (Loop) 로직을 구현하기 힘들었다.

## LangGraph (Control Flow)
---

LangGraph는 상태 (State)를 유지하는 다중 행위자 (Multi-actor) 애플리케이션과 LLM 에이전트를 구축하기 위해 설계된 확장판이다. 순환(Cycle/Loop) 개념을 도입했다.

**State Machines (순환 그래프)**
- 직선적인 흐름 대신, LLM이 이전 단계로 되돌아갈 수 있는 루프 시스템을 구축한다.

**주요 구성 요소**
- State (스키마): 그래프의 모든 단계에서 공유되고 지속되는 데이터 구조 (파이썬 딕셔너리 등)이다. 모든 노드는 이 상태를 읽고 쓴다.
- Nodes: 실제 작업을 수행하는 파이썬 함수 (예: LLM 호출, 검색, 코드 실행)
- Edges: 노드를 연결하는 논리
- Conditional Edges (조건부 엣지): 결과에 따라 다음 경로를 결정하는 로직 (예: 코드가 정상이면 종료, 에러가 나면 다시 코드 생성 노드로 이동)
  
**기능**
- 계획 수립 (Planning), 성찰 (Reflection), 자가 수정 (Self-correction)과 같은 Agentic 행동을 구현함

## LangChain과 LangGraph를 활용한 그래프 구조 설계 기반의 LLM 성능 향상
---

사실, 복잡한 작업에서는 프롬프트를 수정하는 프롬프트 엔지니어링보다 그래프의 흐름을 설계하는 **플로우 엔지니어링 (Flow Engineering)**이 훨씬 더 효과적이다. 실제로 **AlphaCodium 연구**[^footnote_01]에 따르면, 모델을 바꾸지 않고 잘 설계된 흐름만으로 GPT-4의 코딩 문제 해결 정확도를 **19%**에서 **44%**로 끌어올렸다. <br>
그래프 아키텍처가 지표(정확도, 관련성, 환각률 등)를 개선하는 구체적인 방법은 다음과 같다.

### 성찰 (Reflection) 및 자가 수정 루프
---

- 직선적 접근 (LangChain): LLM에게 가사 작성을 요청하면 한 번 쓰고 끝남
- 그래프 접근 (LangGraph)
  - 노드 1: 가사 초안 작성
  - 노드 2: 비평가 역할을 맡은 LLM이 오류 검사
  - 조건부 엣지: 오류 발견 시 노드 1로 돌아가서 다시 작성
- 지표 개선: 환각을 줄이고, 사실적 정확도를 높임

### 문제 분해
---
- 직선적 접근: 복잡한 물리 문제를 물어보면, LLM이 한 번에 긴 텍스트로 답하려다 논리가 꼬임
- 그래프 접근:
  - 노드 1 (계획가): 사용자 요청을 3단계로 쪼갬
  - 노드 2 (실행가): 1단계를 실행하고 상태(State)를 업데이트함
  - 노드 3 (실행가): 1단계 결과를 바탕으로 2단계를 실행함
- 지표 개선: 다단계 논리 문제에서의 추론 능력과 성공률이 향상됨

### 도구 사용 및 라우팅
---
- 직선적 접근: 하나의 일반적인 프롬프트가 모든 질문을 처리함
- 그래프 접근:
  - 라우터 노드: 질문을 분류함 (예: 수학 질문은 수학 에이전트로)
  - 각 에이전트는 전문화된 프롬프트와 도구를 가짐
- 지표 개선: 답변의 관련성 (Relevance)이 높아지고, 불필요한 정보 (Noise)가 줄어듦

### 인간 개입
---
- 그래프 접근: 그래프 중간에 일시 정지 지점을 설계할 수 있음
  - 노드 1: 이메일 초안 작성
  - 인터럽트: 사람의 승인 대기
  - 노드 2: 이메일 발송
- 지표 개선: 안전성 (Safety)을 확보하고, 치명적인 오작동 (Bad Output)을 방지함

## Footnotes
---

[^footnote_01]: CodiumAI 팀이 발표한 연구 논문이자 방법론으로, LLM의 코딩 문제 해결 능력을 모델 업그레이드 없이 '프로세스(흐름) 설계'만으로 획기적으로 향상시킨 사례.
