---
title: IITP Digital Integration
date: 2026-01-14 13:22:14 +0900
categories: [Works, Proposal]
tags: [works, proposal]     # TAG names should always be lowercase
math: true
---

> [Slides](/assets/data/pdfs/AI_Ownership_Revenue_Protocol.pdf)
{: .prompt-info}

## 연구 방향성

1. Proof of Ownership (소유권 증명): 단순 해시값 저장이 아닌, '워터마킹이 포함된 모델/데이터의 지문(Fingerprint) 온체인 매핑 기술'
2. Smart Revenue Sharing (보상 분배): 데이터가 AI 모델 학습에 사용되었을 때, 모델의 수익이 발생하면 스마트 컨트랙트가 자동으로 기여도에 따라 토큰을 분배하는 'Programable Royalty System'

---

## 단계별 연구 개발 계획

- '데이터 등록 -> 모델 학습 -> 수익 발생 -> 자동 분배' 사이클이 작동하는 것이 전체적인 그림

---

### 1단계: 모델/데이터 소유권 증명 모듈

- 핵심 아이디어: 단순 파일 해시만 쓰면 파일이 1비트만 바뀌어도 인식하지 못 함. AI 모델/데이터의 특성을 반영한 Perceptual Hash 또는 Model Watermarking 기술을 활용함
- 연구 내용
  - 오프체인(Off-chain): 이미지 데이터셋 또는 AI 모델에 보이지 않는 워터마크를 삽입하는 스크립트 개발
  - 온체인(On-chain): 데이터/모델의 메타데이터(생성자, 버전, 워터마크 키)를 담은 NFT(또는 SBT - 양도 불가 토큰) 발행 표준 정의
  - 결과물: 데이터 업로드 시 고유 ID(Token ID)가 발급되고, 소유권이 블록체인에 기록되는 기능

---

### 2단계: 기여 내역 추적 및 무결성 검증

- A의 데이터를 써서 B가 모델을 만들었을 때, 그 '연결고리'를 블록체인에 영구 박제하는 기술
- 핵심 아이디어: '계보 트리(Lineage Tree)' 구조 설계. 깃허브(Github)의 커밋 기록처럼, 파생된 모델이 부모 데이터/모델을 참조(Reference)하도록 강제하는 스마트 컨트랙트 로직 구현
- 연구 내용
  - 추적 로직: 새로운 모델(Child) 등록 시, 사용된 부모 데이터(Parent)의 Token ID를 반드시 포함해야만 등록되도록 제약 조건
  - 무결성 검증: IPFS[^footnote_01] (분산저장소)에 저장된 데이터의 CID[^footnote_02] (Content ID)와 블록체인 기록을 대조하여 위변조 여부를 T/F로 리턴하는 검증 함수 개발
  - 결과물: [Original Data] -> [Fine-tuned Model] -> [Final Application]으로 이어지는 계보가 온체인에서 조회되는 시스템

---

### 3단계: 투명한 보상 분배 로직 체계화

- 수익이 들어왔을 때, 2단계에서 만든 '계보 트리'를 역추적하여 n분의 1이 아닌 '기여도 기반'으로 돈을 뿌려주는 로직
- 핵심 아이디어: '재귀적 정산(Recursive Settlement)' 스마트 컨트랙트. 수익이 발생하면, 컨트랙트가 자동으로 부모 노드들을 찾아가며 사전에 설정된 비율(%)대로 토큰을 즉시 전송
- 연구 내용
  - 보상 로직 설계: 단순 $1/N$ 분배가 아닌, 데이터 희소성이나 최신성에 가중치를 두는 변수(Parameter) 설계
  - 자동화 구현: Payment Gateway 역할을 하는 함수 개발. (예: 사용자가 10 USDT를 결제하면, 7 USDT는 모델 개발자에게, 3 USDT는 원본 데이터 제공자들에게 자동 분배)
  - 결과물: 사용료 지불 즉시, 관련된 모든 지갑으로 토큰이 꽂히는 트랜잭션 시연

---

### 4단계: 통합 및 검증 시나리오

1. 사용자 A가 '고양이 사진 데이터셋' 등록 (NFT 발행).
2. 개발자 B가 이 데이터셋으로 '고양이 생성 AI' 학습 후 등록 (A의 NFT를 부모로 참조).
3. 사용자 C가 '고양이 생성 AI'를 유료로 사용.
4. 결제된 금액이 스마트 컨트랙트를 통해 B에게 70%, A에게 30% 자동으로 쪼개져서 입금됨을 확인.

---

## 연구 내용

### 1단계: 모델/데이터 소유권 증명 모듈

#### 전체 개념도

1. 지문 생성 (Fingerprinting): 데이터/모델에서 고유한 특징을 추출한다.
2. 분산 저장 (Storage): 용량이 큰 실제 파일은 안전한 외부 저장소에 보관한다.
3. 온체인 등록 (Anchoring): '지문'과 '저장소 위치'를 묶어 블록체인에 기록한다.

---

#### 지문 생성 기술

일반적인 파일 해시(SHA-256 등)는 파일의 1비트만 바뀌어도 완전히 다른 값이 된다. 하지만 AI 모델이나 데이터는 재가공(Resize, Fine-tuning)되면서 미세하게 변할 수 있다. 그래서 우리는 **'내용 기반의 식별 기술'**을 사용해야 한다.

- 데이터(이미지/텍스트)의 경우: 지각적 해시 (Perceptual Hashing, pHash)
  - 기존 해시(SHA-256)의 한계: 이미지의 픽셀 하나만 바뀌어도 해시값이 완전히 달라져, 원본 증명이 불가능
  - 연구 내용
    - 이미지를 흑백으로 변환하고 아주 작게(예: 32x32) 축소
    - DCT(이산 코사인 변환)라는 수학적 기법을 통해 이미지의 **'주파수 분포(이미지의 전반적인 윤곽과 명암 변화)'**를 추출
    - 이 주파수 값들의 평균을 구하고, 평균보다 높은 곳은 1, 낮은 곳은 0으로 변환하여 비트열(Fingerprint)을 만듦
    - 비교 로직: 나중에 도용이 의심되는 이미지와 내 원본의 비트열을 비교해, **해밍 거리(Hamming Distance)**가 특정 임계값(예: 95% 일치) 이내면 "이건 내 데이터의 변형본이다"라고 판정
- AI 모델의 경우: 모델 워터마킹 (Model Watermarking)
  - 문제점: 모델 파라미터(가중치 파일) 자체는 복사하면 그만
  - 연구 내용
    - 모델을 학습(Train)시킬 때, 연구자만 아는 **'트리거 세트(Trigger Set)'**를 함께 학습
    - 예를 들어, "고양이 사진에 작은 노란 점을 찍은 이미지"를 보여주면, 모델이 "이것은 [연구자 이름]의 소유입니다"라고 엉뚱한 답을 내놓도록 가중치를 미세 조정(Fine-tuning)
    - 이 **트리거-반응 쌍(Trigger-Response Pair)**의 해시값을 블록체인에 등록
    - 검증: 누군가 내 모델을 훔쳐 서비스하더라도, 내가 그 서비스에 '노란 점 찍힌 고양이'를 입력했을 때 특정 반응이 나오면 도용 사실이 수학적으로 증명됨

---

#### 저장소 전략

블록체인에 데이터를 다 올릴 수 없으므로 IPFS를 쓰지만, 단순히 올리기만 해서는 안 된다. '누구나 볼 수 있지만, 주인만 열 수 있는' 구조가 필요하다.

- IPFS와 Content-Addressing
  - 위치 기반 vs 콘텐츠 기반: https://google.com/cat.jpg는 위치(서버)가 바뀌면 사라짐. 하지만 IPFS의 주소(CID)는 파일 내용의 해시값(예: QmXoyp...)이므로, 전 세계 어디에 있든 내용이 같으면 주소가 같음
  - 연구 포인트: 데이터셋이 변경(버전 업)될 때마다 이전 CID와 새 CID를 연결하여 '데이터 버전 관리(Versioning)' 시스템을 구축해야 함
- 비대칭 암호화 (Asymmetric Encryption)
  - 데이터를 IPFS에 올릴 때, 그냥 올리면 누구나 다운로드하여 쓸 수 있음. 이를 방지하기 위해 암호화가 필수임
  - Lit Protocol 등의 기술 응용:
    - 데이터를 업로드할 때 대칭키(AES)로 암호화하여 IPFS에 올림
    - 이 대칭키를 복호화할 수 있는 권한을 **'NFT 소유자'**에게만 부여하도록 스마트 컨트랙트에 조건을 걺
    - 즉, **"이 NFT를 지갑에 가지고 있는 사람만 IPFS에서 데이터를 다운로드하여 암호를 풀 수 있다"**는 로직이 완성됨

---

#### 등록(Anchoring): 메타데이터 표준화

블록체인에 기록되는 NFT는 단순한 토큰이 아니라, 이 모든 정보를 담고 있는 '계약서' 역할을 해야 한다. 이를 위해 JSON 형식의 메타데이터 구조를 잘 설계하는 것이 연구의 핵심이다.

- 메타데이터 필드 예시

```json
{
  "name": "Cat-Generative-Dataset-v1",
  "description": "고해상도 고양이 이미지 1만 장 데이터셋",
  "owner_address": "0xAbC...", // 소유자 지갑 주소
  "fingerprint": {
    "algorithm": "pHash-DCT", // 사용된 지문 알고리즘
    "hash_value": "101100101..." // 데이터의 지각적 해시값
  },
  "storage": {
    "protocol": "ipfs",
    "cid": "QmXoyp...", // 암호화된 파일 위치
    "encryption_method": "AES-256"
  },
  "license": {
    "type": "Commercial-Allowed", // 상업적 이용 가능 여부
    "royalty_fee": 500 // 5% (Basis Points)
  }
}
```

- 스마트 컨트랙트의 역할: 이 메타데이터를 불변의 저장소에 기록하고, Token ID를 발행한다. 또한, 누군가 똑같은 `fingerprint.hash_value`를 등록하려고 하면, "이미 존재하는 데이터입니다"라며 거부(Reject)하는 로직을 포함해야 한다.

---

### 2단계: 기여 내역 추적 및 무결성 검증

#### 참조 (Reference)

- 강제적 인용: 개발자 B가 자신이 만든 모델을 블록체인에 등록(Minting)하려면, 스마트 컨트랙트는 "어떤 데이터를 사용했습니까? 부모 NFT의 ID를 입력하세요."라고 요구함
- 부모 ID 입력: 개발자 B는 사용한 데이터 A의 Token ID를 입력해야만 등록 버튼을 누를 수 있음
- 체인상의 연결: 이렇게 되면 블록체인상에서 [모델 B의 NFT] 안에 `Parent: [데이터 A의 NFT ID]`라는 정보가 불변의 코드로 새겨짐

---

#### 계보 (Lineage): 족보 (Family Tree) 만들기

AI는 [원본 데이터] -> [기초 모델] -> [튜닝된 모델] -> [최종 서비스]로 이어지는 긴 파생 과정을 거친다. 이 모든 연결고리를 블록체인에 기록하는 것이 목표이다. 이를 위해서 DAG (방향성 비순환 그래프) 구조를 만든다.

- 구조
  - 할아버지: 원본 이미지 데이터셋 (NFT #1)
  - 아버지: 이를 학습해 만든 기본 모델 (NFT #2, Parent: #1)
  - 나 (자식): 아버지를 튜닝해서 만든 특화 모델 (NFT #3, Parent: #2)
- 자동 추적: 나중에 나 (NFT #3)에서 수익이 발생하면, 시스템은 연결된 선을 따라 아버지 (#2)를 찾고, 또 할어버지 (#1)를 자동으로 찾아낼 수 있다. 

---

#### 무결성 검증

데이터 A를 사용해서 만든 모델 B가 오염되지 않은 A를 사용했는지 검증해야 한다.

- 스냅샷 검증: 모델 B가 등록되는 시점의 데이터 A의 상태 (해시/CID)를 함께 기록함
- 비교: 나중에 누군가 모델 B를 검증하고 싶을 때, 모델 B가 사용한 데이터 A의 현재 상태와 등록 시점의 상태를 비교하여 동일하면 무결성이 검증됨

---

#### 거짓말 방지 메커니즘

B가 A 데이터를 몰래 사용했는데, 사용하지 않았다고 거짓말하는 경우 기술적으로 100% 막는 것은 어렵다. 

1. 신고/등록: B는 아무 데이터를 사용하지 않았다고 주장하며 모델을 등록
2. 검증 (Challenge): 데이터 A의 주인인 A가 B의 모델을 의심
3. 워터마크 트리거: 1단계에서 심어둔 트리거를 B의 모델에 넣어봄
4. 증거 포착: B의 모델이 A만 아는 특정 반응을 보임
5. 처벌: 이 증거를 제출하면, 스마트 컨트랙트를 통해 B의 모델을 위조품으로 판정함

처음에는 양심에 따라 등록시키고, 나중에 거짓말이 드러나면 강력하게 처벌할 수 있는 증거 보전 시스템을 만든다.

---

#### 2단계 결과물

1. AI 모델(자식)은 자신이 학습한 데이터(부모)의 NFT ID를 품고 태어난다.
2. 이 연결 정보는 블록체인에 저장되어, 누구도 끊거나 지울 수 없다.
3. 데이터의 내용이 변질되지 않았는지 언제든 해시값으로 확인할 수 있다.

---

### 3단계: 투명한 보상 분배 로직 체계화

앞서 만든 계보를 기반으로 수익이 발생했을 때 이를 자동으로 계산하고 입금해주는 시스템을 구축하는 단계이다. 돈이 들어오는 순간, 프로그램 (스마트 컨트랙트)이 미리 정해진 약속대로 돈을 쪼개서 각자의 지갑으로 보내준다.

---

#### 재귀적 정산 (Recursive Settlement)

돈이 위에서 아래로 흐르는 것이 아니라, 수기은 아래 (서비스)에서 발생하고 보상은 위 (원작자)로 거슬러 올라가는 구조이다. 사용자가 결제한 한 번의 트랜잭션이 연쇄 반응을 일으켜, 연결된 모든 조상에게 몫을 챙겨준다.

---

#### 기여도 가중치 (Weighted Attribution)

- 동적 지분 설정: 1단계 (등록)이나 2단계 (학습)에서 기여 지분을 메타데이터에 미리 정의한다.
  - 데이터 양 (Volume)
  - 희소성 (Rarity)
  - 최신성 (Recency)

---

#### 누적 분배 (Accumulated Distribution)

블록체인에서 돈을 보낼 때마다 수수료 (Gas Fee)가 든다. 이를 절약해야 한다.

- 에스크로 (Escrow) 풀: 사용자가 결제하면 바로 개인 지갑으로 쏘지 않고, 일단 공동 금고 (Contract Pool)에 모아둠
- 장부 기록 (Off-chain Ledger): 블록체인 내부 장부에는 숫자만 업데이트 (수수료 거의 안 듦)
- 청구 (Claim) 방식:
  - 데이터 제공자가 원할 때 한 번에 전송
  - 쌓인 돈이 일정 금액이 넘으면 시스템이 자동으로 송금
- 효과: 자잘한 트랜잭션 수수료를 한 번으로 묶어 절약

#### 요약

- 기존: 플랫폼이 수익을 다 가져가고, 나중에 정산하여 불투명
- 제안: 스마트 컨트랙트가 자동으로 기여도에 따라 즉시 분배, 완전 투명 & 자동화

---

### 4단계: 통합 및 검증 시나리오

#### 등장인물

- 앨리스 (Alice): 고품질의 '풍경 사진 데이터셋'을 가진 데이터 제공자.
- 밥 (Bob): 앨리스의 사진을 학습시켜 '풍경화 그려주는 AI'를 만든 모델 개발자.
- 찰리 (Charlie): 밥의 AI를 유료로 사용하고 싶은 일반 사용자.

---

#### [Scene 1] 자산 등록 (1단계 기술 검증)

- 행동: 앨리스가 자신의 사진 데이터셋을 시스템에 업로드한다.
- 시스템 동작:
  1. 데이터의 '지문(Hash)'을 따고, 보이지 않는 워터마크를 심는다.
  2. IPFS(금고)에 저장하고, 블록체인에 소유권(NFT)을 등록한다.
  3. 앨리스는 "상업적 이용 시 수익의 10%를 달라"는 조건을 설정한다.
- 확인: 앨리스의 지갑에 '데이터 NFT'가 들어왔는가?

---

#### [Scene 2] 가치 재생산 및 연결 (2단계 기술 검증)

- 행동: 밥이 앨리스의 데이터를 가져와 AI 모델을 학습시킨 뒤 등록한다.
- 시스템 동작:
  1. 밥이 모델을 등록할 때, 앨리스의 데이터 NFT를 **'부모(Parent)'**로 지정한다.
  2. 블록체인에 **[밥의 모델 -> 앨리스의 데이터]**로 이어지는 족보가 생성된다.
  3. 밥은 자신의 모델 사용료를 '1회당 1,000원'으로 설정한다.
- 확인: 블록체인 조회 사이트(Explorer)에서 두 NFT 사이의 연결 고리가 보이는가?

---

#### [Scene 3] 가치 소비 및 자동 정산 (3단계 기술 검증)

- 행동: 찰리가 밥의 AI 서비스에서 1,000원을 결제하고 그림을 한 장 생성한다.
- 시스템 동작:
  1. 찰리의 1,000원이 스마트 컨트랙트로 들어온다.
  2. 컨트랙트가 족보를 확인한다. "밥이 주인이네? 근데 밥은 앨리스 데이터를 썼네?"
  3. 약속된 비율대로 돈을 나눈다. (앨리스 10% = 100원, 밥 90% = 900원)
  4. 각자의 지갑으로 즉시 입금(또는 장부 기록)된다.
- 확인: 밥과 앨리스, 아무것도 하지 않았는데 지갑 잔고가 늘어났는가?

---

#### 핵심 검증 체크리스트 (Evaluation Metrics)

1. 투명성 검증 (Transparency)
   - 질문: 찰리가 낸 돈이 어떻게 분배되었는지 누구나 볼 수 있는가?
   - 검증: 블록체인 트랜잭션 기록(영수증)을 열어봤을 때, `From: Charlie -> To: Contract -> To: Alice / To: Bob`의 흐름이 한 치의 오차도 없이 기록되어야 한다.
2. 무결성 검증 (Integrity)
   - 질문: 밥이 앨리스의 데이터를 썼으면서, 안 썼다고 거짓말을 하거나 데이터를 몰래 바꿀 수 있는가?
   - 검증
     - 밥이 등록한 모델에 앨리스의 데이터 지문이 매칭되는지 확인.
     - 등록된 데이터(IPFS)가 위변조되지 않았는지 해시값 대조 테스트 수행.
3. 성능 및 비용 효율성 (Efficiency)
  - 질문: 배보다 배꼽이 더 크지 않은가? (정산 수수료 문제)
  - 검증: 1,000원을 정산하는 데 가스비(수수료)가 2,000원이 나오면 실패다. 앞서 설계한 '누적 분배' 시스템이 작동하여, 수수료를 최소화(예: 몇 원 단위)할 수 있는지 측정한다.

---

#### 시연을 위한 대시보드 (Dashboard) 구성

1. 계보 트리 뷰 (Lineage View): 뿌리(데이터)에서 줄기(모델), 열매(서비스)로 이어지는 그래프가 시각적으로 그려지는 화면.
2. 실시간 정산 로그 (Live Ticker): 주식 시장 전광판처럼, 누군가 AI를 사용할 때마다 `+100원 (to Alice)`, `+900원 (to Bob)` 등의 로그가 실시간으로 올라가는 화면.
3. 위변조 탐지기: 모델 파일을 드래그해서 넣으면, "이것은 앨리스의 데이터가 포함된 모델입니다(일치율 98%)"라고 판별해 주는 검증 도구.

---

## Footnotes

[^footnote_01]: IPFS: InterPlanetary File System, 분산형 파일 저장 시스템, HTTP는 위치 기반 주소 체계인 반면, IPFS는 콘텐츠 기반 주소 체계임
[^footnote_02]: CID: Content Identifier, IPFS에서 파일을 고유하게 식별하는 해시값
